## 聊天服务器

[TOC]

### 1.项目简介

本项目主要的平台为linux平台，也兼容windows平台；是一个公司内部的聊天服务器的建议版本。本项目的网络库借鉴了muduo库，在其基础上使用c++11重写了一套网络基础库。基于Reactor设计模式，采用了多路IO复用的技术。实现了简单易用的线程池，支持多线程；以及数据库连接池。采用最小堆实现了定时器的处理，支持心跳包以及短线重连机制，实现了简单易用的服务器端日志系统，同时也支持更为简单的同步日志系统，采用JOSN进行数据传输，支持传输数据的压缩。

### 2.网络库的介绍

- Buffer缓冲区
- 事件循环对象
- 事件循环线程池
- 基础的Socket封装，地址的封装，大小端数据转换的封装
- 连接接收器
- Channel
- Tcp连接对象
- 分发器及其派生类（IO复用函数的封装）
- 定时器
- Tcp服务器
- Tcp客户端

#### 1.循环事件对象

（1）循环事件对象中有什么？

```
1.循环事件对象所属的线程id
2.分发器（IO复用的封装）
3.计时器队列
4.唤醒Channel
5.激活的Channel链表
6.当前Channel指针
7.互斥量
等等，上述几个为最为重要的成员变量
```

（2）初始化循环事件

```C++
// 在线程函数中创建eventloop
EventLoop::EventLoop()
    : looping_(false),
    quit_(false),
    eventHandling_(false),
    callingPendingFunctors_(false),
    threadId_(std::this_thread::get_id()),
    timerQueue_(new TimerQueue(this)),
    iteration_(0L),
    currentActiveChannel_(NULL)
{
    //以下是创建修改唤醒Channel的流程，
    createWakeupfd();
#ifdef WIN32
    wakeupChannel_.reset(new Channel(this, wakeupFdSend_));
    poller_.reset(new SelectPoller(this));

#else

    //这里调用的是linux下的代码
    wakeupChannel_.reset(new Channel(this, wakeupFd_));
    poller_.reset(new EPollPoller(this));
#endif

    if (t_loopInThisThread)
    {
        LOGF("Another EventLoop  exists in this thread ");
    }
    else
    {
        t_loopInThisThread = this;
    }
    wakeupChannel_->setReadCallback(std::bind(&EventLoop::handleRead, this));
    // we are always reading the wakeupfd
    wakeupChannel_->enableReading();
}
```

为什么需要一个唤醒线程？

（3）启动循环事件

```c++
void EventLoop::loop()
{
    assertInLoopThread();
    looping_ = true;
    quit_ = false;  // FIXME: what if someone calls quit() before loop() ?
    LOGD("EventLoop 0x%x  start looping", this);

    //主循环
    while (!quit_)
    {
        timerQueue_->doTimer();			//处理定时器事件

        activeChannels_.clear();		//清空Channel
        pollReturnTime_ = poller_->poll(kPollTimeMs, &activeChannels_);
        printActiveChannels();
        ++iteration_;
        eventHandling_ = true;	//当前循环是否在处理事件
        for (const auto& it : activeChannels_)
        {
            currentActiveChannel_ = it;
            currentActiveChannel_->handleEvent(pollReturnTime_);
            //处理对应的Channel事件
        }
        currentActiveChannel_ = nullptr;
        eventHandling_ = false;
        doPendingFunctors();		//处理一些Pend的事件

        if (frameFunctor_)
        {
            frameFunctor_();
        }
    }
	//退出循环之后打印日志
    LOGD("EventLoop 0x%0x stop looping", this);
    looping_ = false;
    std::ostringstream oss;
    oss << std::this_thread::get_id();
    std::string stid = oss.str();
    LOGI("Exiting loop, EventLoop object: 0x%x , threadID: %s", this, stid.c_str());
}
```

#### 2.TCPServer对象

（1）拥有的成员

```
1.主循环指针，指向主循环
2.连接接收器(Acceptor),使用独占式的智能指针管理
3.事件循环线程池(EventLoopThreadPool),使用独占式的智能指针管理
4.一些回调函数
5.TcpConnetion的Map，typedef std::map<string, TcpConnectionPtr> ConnectionMap;(连接对象的哈希表)
typedef std::shared_ptr<TcpConnection> TcpConnectionPtr;
....上述是比较重要的对象，其他的对象见TcpServer.h文件
```

（2）初始化服务器

```C++
TcpServer::TcpServer(EventLoop* loop,
    const InetAddress& listenAddr,	//传入封装的IP端口和地址
    const std::string& nameArg,		//服务器名字
    Option option)					//是否支持端口复用选项
    : loop_(loop),
    hostport_(listenAddr.toIpPort()),
    name_(nameArg),
    acceptor_(new Acceptor(loop, listenAddr, option == kReusePort)),				//这里初始化创建了Acceptor对象
    connectionCallback_(defaultConnectionCallback),
    messageCallback_(defaultMessageCallback),
    started_(0),
    nextConnId_(1)
{
    acceptor_->setNewConnectionCallback(std::bind(&TcpServer::newConnection, this, std::placeholders::_1, std::placeholders::_2));
    //将接收器的新连接回调函数设置为TcpServer::newConnetion()函数。
}
```

##### Acceprot对象

这里为了解释TcpServer需要先介绍下Acceptor对象，接收器对象实际上是一个较为底层的对象，可以视作是一个监听套接字的封装。

该对象始终监听读时间，并且将新的连接挂在到epollfd上去。

（1）Acceptor对象的成员变量和函数

```
1.指向一个循环的指针，表明该接收器属于哪一个对象
2.封装之后的接收器SOCKET
3.接收器Channel
4.新连接回调函数，NewConnetionCallback
5.handeRead()函数，用于处理读事件
```

（2）Acceptor对象的构造函数

```c++
Acceptor:: Acceptor(EventLoop* loop, const InetAddress& listenAddr, bool reuseport)
    : loop_(loop),
    acceptSocket_(sockets::createNonblockingOrDie()),   //创建套接字之后将之设置为阻塞。
    acceptChannel_(loop, acceptSocket_.fd()),			//创建Channel
    listenning_(false)   								//设置表示为非监听状态
{
#ifndef WIN32
    idleFd_ = ::open("/dev/null", O_RDONLY | O_CLOEXEC);
#endif
    acceptSocket_.setReuseAddr(true);					
    acceptSocket_.setReusePort(reuseport);
    acceptSocket_.bindAddress(listenAddr);			//设置接受套接字为端口复用，绑定地址，
    acceptChannel_.setReadCallback(std::bind(&Acceptor::handleRead, this));  //将channel的读事件处理函数设置为接收器的handleRead函数。
}
```

##### Channel对象

Channel对是底层的Socket对象之上的一层对象，是对套接字的进一层封装，并且拥有自己的不同的回调函数。

（1）重要的成员对象

```
1.所属的循环，指向循环事件的指针
2.文件描述符
3.注册事件   events_
4.返回事件	 revents_
	index_		代表这个Channel的状态，是删除还是新建？
四个回调函数
```

重点介绍下，Channel的重要私有函数

```C++
void handleEventWithGuard(Timestamp receiveTime);
接收一个时间戳,然后根据Channel中成员的返回事件来进行事件的处理，调用不同的回调函数。
构造函数：
Channel::Channel(EventLoop* loop, int fd__): loop_(loop),
                                            fd_(fd__),
                                            events_(0),
                                            revents_(0),
                                            index_(-1),
                                            logHup_(true),
                                            tied_(false)/*,
                                            eventHandling_(false),
                                            addedToLoop_(false)
                                            */
                                            {}
```

（3）TcpServer的start()函数

TcpServer中的成员对象循环事件线程池，并没有在初始化的时候就被创建，而是在Start函数中使用智能指针的reset函数创建，

```C++
void TcpServer::start(int workerThreadCount/* = 4*/)
{
    if (started_ == 0)
    {
        eventLoopThreadPool_.reset(new EventLoopThreadPool());		//创建线程池
        eventLoopThreadPool_->init(loop_, workerThreadCount);		//初始化线程池
        eventLoopThreadPool_->start();								//启动线程池
        
        //threadPool_->start(threadInitCallback_);
        //assert(!acceptor_->listenning());
        loop_->runInLoop(std::bind(&Acceptor::listen, acceptor_.get()));
        started_ = 1;
    }
}
```

##### 循环事件线程池

（1）循环事件线程池的成员变量

```
		EventLoop*                                      baseLoop_;				//所属的主线程
		std::string                                     name_;					//线程名字
		bool                                            started_;				//启动标志
		int                                             numThreads_;			//启动线程数量
		int                                             next_;		
		std::vector<std::unique_ptr<EventLoopThread> >  threads_;				//线程池对象智能指针数组
		std::vector<EventLoop*>                         loops_;					//循环事件对象指针数组
```

（2）构造函数

```C++
EventLoopThreadPool::EventLoopThreadPool()
    : baseLoop_(NULL),
    started_(false),
    numThreads_(0),
    next_(0)
    {}
```

（3）init()函数

此函数没有真正的创建线程，而是设定了开启的线程数量以及指定主线程

```C++
void EventLoopThreadPool::init(EventLoop* baseLoop, int numThreads)
{
    numThreads_ = numThreads;
    baseLoop_ = baseLoop;
}
```

（4）start()函数

这个函数需要重点理解下，什么时候创建了线程？

```C++
void EventLoopThreadPool::start(const ThreadInitCallback& cb)
{
    if (baseLoop_ == NULL)
        return;      
    //这时候started_还没有创建
    if (started_)
        return;
    baseLoop_->assertInLoopThread();
    started_ = true;

    //创建线程的循环，重要
    for (int i = 0; i < numThreads_; ++i)
    {
        char buf[128];
        snprintf(buf, sizeof buf, "%s%d", name_.c_str(), i);
        //设定线程的名字
        
        //创建出循环线程对象，这个对象之中含有线程对象。
        std::unique_ptr<EventLoopThread> t(new EventLoopThread(cb, buf));
        //这里仅仅是创建了循环事件线程，没有并没有真正的执行线程函数
        
        loops_.push_back(t->startLoop());		//才真正的执行了线程函数，并且返回对应线程所属的loop
        threads_.push_back(std::move(t));   	//使用了移动语句，将线程对象交给线程池管理
    }
    if (numThreads_ == 0 && cb)
    {
        cb(baseLoop_);
    }
}
```

需要先介绍下循环事件线程对象,才方便理解这个函数

##### 循环事件线程对象

（1）循环事件对象的成员变量与部分函数

```
	private:
		void threadFunc();				//线程执行函数

		EventLoop*                   loop_;			//循环事件,此线程所属的循环事件对象
		bool                         exiting_;		//退出标志	
		std::unique_ptr<std::thread> thread_;		//独占式的智能指针指向C++11的线程对象
		std::mutex                   mutex_;		//互斥锁
		std::condition_variable      cond_;			//条件变量
		ThreadInitCallback           callback_;		//线程执行函数
	};
```

（2）重要的成员函数

```C++
//构造函数，什么也没有做
EventLoopThread::EventLoopThread(const ThreadInitCallback& cb,
								 const std::string& name/* = ""*/)
								 : loop_(NULL),
								 exiting_(false),
								 callback_(cb)
                                 {}
//真正创建了线程，返回线程所属的循环事件。
EventLoop* EventLoopThread::startLoop()
{
	thread_.reset(new std::thread(std::bind(&EventLoopThread::threadFunc, this)));
	{	
        //下面是条件变量的经典使用方法：
		std::unique_lock<std::mutex> lock(mutex_);		
		while (loop_ == NULL)			//这个loop_什么时候创建的？
		{
			cond_.wait(lock);			//当条件变量被唤醒的时候，跳出该循环
		}
        
	}
	return loop_;		//返回此线程所属于的loop
}

//真实的线程执行函数
void EventLoopThread::threadFunc()
{
	EventLoop loop;		//临时变量，但是只要这个函数不退出作用域，就会一直生效，这个就是返回的线程

	if (callback_)
	{
		callback_(&loop);
	}

	{
		//一个一个的线程创建
        std::unique_lock<std::mutex> lock(mutex_);
		loop_ = &loop;
		cond_.notify_all();		//唤醒阻塞的条件变量
	}

	loop.loop();				//调用循环事件的loop函数会一直阻塞在这里。
	loop_ = NULL;
}
```

### 3.服务器的响应流程

#### 1. 新的用户连接上服务器的流程

##### 分发器对象(EPollpoller)

（1）分发器对象的成员变量

```C++
//继承于基础的分发器，是循环事件的成员变量，一个循环事件对象拥有一个分发器。
private:
		static const int kInitEventListSize = 16;
		//向激活channel链表中插入相应的channel指针
		void fillActiveChannels(int numEvents, ChannelList* activeChannels) const;
		bool update(int operation, Channel* channel);		

	private:
		typedef std::vector<struct epoll_event> EventList;			//epoll_event事件数组

		int                                     epollfd_;		//create_epoll()返回的fd。
		EventList                               events_;		//接受返回的eventfd的结构体

		typedef std::map<int, Channel*>         ChannelMap;

		ChannelMap                              channels_;		//channel的映射表
		EventLoop*                              ownerLoop_;		//所属于的循环
```

（2）初始化函数

在loop的构造函数中初始化了分发器对象

```C++
poller_.reset(new EPollPoller(this));			//在EventLoop::EventLoop()函数中

EPollPoller::EPollPoller(EventLoop* loop)
    :epollfd_(::epoll_create1(EPOLL_CLOEXEC)),
    events_(kInitEventListSize),
    ownerLoop_(loop)
{
    if (epollfd_ < 0)
    {
        LOGF("EPollPoller::EPollPoller");
    }
}
```

在TcpServer的启动函数的最后，调用主循环的runInloop()函数运行接收器的listen()函数

```
注册读读事件的流程:
归根到底需要调用epoll_ctl对事件进行注册，下面表现了从Channel到循环事件中的的分离器的过程，最终
调用Channel::enableRead()函数------------------->
Channel::update()函数--------------------------->
loop_::updateChannel()函数---------------------->
pool_::updateChannel()函数---------------------->
pool_::update()函数,此函数才是真正调用epoll_ctl函数的的封装函数。
```

```C++
 loop_->runInLoop(std::bind(&Acceptor::listen, acceptor_.get()));
//这个的get()函数，可以获取对应的函数
void Acceptor::listen()
{
    loop_->assertInLoopThread();
    listenning_ = true;							//将监听状态设置为监听
    acceptSocket_.listen();						//调用套接字对象的监听函数
    acceptChannel_.enableReading();				//设置channel为可读事件
}

//注册读事件
bool Channel::enableReading() 
{ 
    events_ |= kReadEvent;			//设置Channel的事件为可读
    return update();				//更新Channel，实际是调用循环对象的Channel更新函数。
}

bool Channel::update()
{
	return loop_->updateChannel(this);				//实际上调用了Loop的UpdateChannel()函数
}

bool EventLoop::updateChannel(Channel* channel)
{
    if (channel->ownerLoop() != this)
        return false;
    assertInLoopThread();
    return poller_->updateChannel(channel);			//实际上调用了分离器的updateChannel函数
}


//注意这个index，或者index是什么?这个index是channel中的index，，在创建Channel的时候被初始化为-1.
//弄清楚这个index的变化情况。

namespace
{
    const int kNew = -1;						//初始化的时候，被设置为-1
    const int kAdded = 1;
    const int kDeleted = 2;
}


bool EPollPoller::updateChannel(Channel* channel)
{
    assertInLoopThread();
    LOGD("fd = %d  events = %d", channel->fd(), channel->events());
    const int index = channel->index();						//初始化的时候是-1
    if (index == kNew || index == kDeleted)
    {
        // a new one, add with XEPOLL_CTL_ADD
        int fd = channel->fd();
        if (index == kNew)				//表示新连接
        {
            if (channels_.find(fd) != channels_.end())
            {
                LOGE("fd = %d  must not exist in channels_", fd);
                return false;
            }
            channels_[fd] = channel;
        }
        else // index == kDeleted
        {
            if (channels_.find(fd) == channels_.end())
            {
                LOGE("fd = %d  must exist in channels_", fd);
                return false;
            }
            if (channels_[fd] != channel)
            {
                LOGE("current channel is not matched current fd, fd = %d", fd);
                return false;
            }
        }
        channel->set_index(kAdded);				//设置index为已添加的
        return update(XEPOLL_CTL_ADD, channel);
    }
    else
    {
        int fd = channel->fd();
        if (channels_.find(fd) == channels_.end() || channels_[fd] != channel || index != kAdded)
        {
            LOGE("current channel is not matched current fd, fd = %d, channel = 0x%x", fd, channel);
            return false;
        }
        if (channel->isNoneEvent())
        {
            if (update(XEPOLL_CTL_DEL, channel))
            {
                channel->set_index(kDeleted);
                return true;
            }
            return false;
        }
        else
        {
            return update(XEPOLL_CTL_MOD, channel);
        }
    }
}

//实际调用的函数
bool EPollPoller::update(int operation, Channel* channel)
{
    struct epoll_event event;
    memset(&event, 0, sizeof event);
    event.events = channel->events();
    event.data.ptr = channel;
    int fd = channel->fd();
    if (::epoll_ctl(epollfd_, operation, fd, &event) < 0)
    {
        if (operation == XEPOLL_CTL_DEL)
        {
            LOGE("epoll_ctl op=%d fd=%d, epollfd=%d, errno=%d, errorInfo: %s", operation, fd, epollfd_, errno, strerror(errno));
        }
        else
        {
            LOGE("epoll_ctl op=%d fd=%d, epollfd=%d, errno=%d, errorInfo: %s", operation, fd, epollfd_, errno, strerror(errno));
        }

        return false;
    }

    return true;
}
```

